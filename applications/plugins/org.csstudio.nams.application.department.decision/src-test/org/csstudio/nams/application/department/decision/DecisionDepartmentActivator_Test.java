package org.csstudio.nams.application.department.decision;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import junit.framework.Assert;
import junit.framework.TestCase;

import org.csstudio.nams.common.material.SyncronisationsAufforderungsSystemNachchricht;
import org.csstudio.nams.common.material.SyncronisationsBestaetigungSystemNachricht;
import org.csstudio.nams.common.material.SystemNachricht;
import org.csstudio.nams.common.material.regelwerk.Regelwerk;
import org.csstudio.nams.common.service.ExecutionServiceMock;
import org.csstudio.nams.service.configurationaccess.localstore.declaration.ConfigurationServiceFactory;
import org.csstudio.nams.service.configurationaccess.localstore.declaration.DatabaseType;
import org.csstudio.nams.service.configurationaccess.localstore.declaration.LocalStoreConfigurationService;
import org.csstudio.nams.service.configurationaccess.localstore.declaration.ReplicationStateDTO;
import org.csstudio.nams.service.configurationaccess.localstore.declaration.ReplicationStateDTO.ReplicationState;
import org.csstudio.nams.service.configurationaccess.localstore.declaration.exceptions.InconsistentConfigurationException;
import org.csstudio.nams.service.configurationaccess.localstore.declaration.exceptions.StorageError;
import org.csstudio.nams.service.configurationaccess.localstore.declaration.exceptions.StorageException;
import org.csstudio.nams.service.configurationaccess.localstore.declaration.exceptions.UnknownConfigurationElementError;
import org.csstudio.nams.service.history.declaration.HistoryService;
import org.csstudio.nams.service.logging.declaration.LoggerMock;
import org.csstudio.nams.service.messaging.declaration.Consumer;
import org.csstudio.nams.service.messaging.declaration.ConsumerMock;
import org.csstudio.nams.service.messaging.declaration.DefaultNAMSMessage;
import org.csstudio.nams.service.messaging.declaration.DefaultNAMSMessage.AcknowledgeHandler;
import org.csstudio.nams.service.messaging.declaration.MessagingServiceMock;
import org.csstudio.nams.service.messaging.declaration.MessagingSession;
import org.csstudio.nams.service.messaging.declaration.MessagingSessionMock;
import org.csstudio.nams.service.messaging.declaration.MultiConsumersConsumer.MultiConsumerConsumerThreads;
import org.csstudio.nams.service.messaging.declaration.NAMSMessage;
import org.csstudio.nams.service.messaging.declaration.PostfachArt;
import org.csstudio.nams.service.messaging.declaration.Producer;
import org.csstudio.nams.service.messaging.declaration.ProducerMock;
import org.csstudio.nams.service.messaging.exceptions.MessagingException;
import org.csstudio.nams.service.preferenceservice.declaration.PreferenceService;
import org.csstudio.nams.service.preferenceservice.declaration.PreferenceServiceDatabaseKeys;
import org.csstudio.nams.service.preferenceservice.declaration.PreferenceServiceJMSKeys;
import org.csstudio.nams.service.regelwerkbuilder.declaration.RegelwerkBuilderService;
import org.easymock.EasyMock;
import org.eclipse.equinox.app.IApplicationContext;
import org.junit.Ignore;
import org.junit.Test;

public class DecisionDepartmentActivator_Test extends TestCase {

    boolean syncronisationBestaetigungAcknowledged;
    volatile Throwable occuredThrowable = null;
    private LoggerMock logger;
    private MessagingServiceMock messagingService;
    private PreferenceService preferenceService;
    private RegelwerkBuilderService regelwerksBuilderService;
    private HistoryService historyService;
    private LocalStoreConfigurationService localStoreConfigurationService;
    private ExecutionServiceMock executionService;

    private ProducerMock amsToDistributorProducerMock;

    private ConsumerMock amsCommandConsumerMock;

    private final ThreadGroup catchingThreadGroup =
        new ThreadGroup(Thread.currentThread().getThreadGroup(), "DDA") {
        @Override
        public void uncaughtException(final Thread t, final Throwable e) {
            DecisionDepartmentActivator_Test.this.occuredThrowable = e;
        }
    };

    // FIXME mz 2008-07-18: This Test has to be fixed and conitnued
    @Test
    @Ignore("This test does not seem to be current in any reasonable way.")
    public void testBundleAndApplicationLifecycle() throws Throwable {

        if (1 == 1) {
            return; // FIXME mz: 2008-07-21 Test wieder ausführen, dringend!
        }

        final DecisionDepartmentActivator bundleInstance = new DecisionDepartmentActivator();
        final DecisionDepartmentActivator applicationInstance = new DecisionDepartmentActivator();

        bundleInstance.startBundle(this.logger,
                                   this.messagingService,
                                   this.preferenceService,
                                   this.regelwerksBuilderService,
                                   this.historyService,
                                   new ConfigurationServiceFactory() {
            /**
             * {@inheritDoc}
             */
            @Override
            public LocalStoreConfigurationService getConfigurationService(final String connectionURL,
                                                                          final DatabaseType dbType,
                                                                          final String username,
                                                                          final String password) {
                return DecisionDepartmentActivator_Test.this.localStoreConfigurationService;
            }},
            this.executionService);

        Thread.yield();

        this.syncronisationBestaetigungAcknowledged = false;
        this.amsCommandConsumerMock
        .mockSetNextToBeDelivered(new DefaultNAMSMessage(
                                                         new SyncronisationsBestaetigungSystemNachricht(),
                                                         new AcknowledgeHandler() {
                                                             public void acknowledge() throws Throwable {
                                                                 DecisionDepartmentActivator_Test.this.syncronisationBestaetigungAcknowledged = true;
                                                             }
                                                         }));

        final Runnable appRun = new Runnable() {
            public void run() {
                try {
                    Thread.sleep(2000); // FIXME Was besseres übelegen!
                    // (Application Konzept mit einer run
                    // ist nicht gut - init müsste
                    // ausgelagert werden.)

                    // Hier läuft der Test!!!!!!!!!!!
                    DecisionDepartmentActivator_Test.this.executionService
                    .mockExecuteOneStepOf(MultiConsumerConsumerThreads.CONSUMER_THREAD);

                    Thread.sleep(2000);

                    applicationInstance.stop();

                    bundleInstance
                    .stopBundle(DecisionDepartmentActivator_Test.this.logger);

                    Assert
                    .assertTrue(DecisionDepartmentActivator_Test.this.syncronisationBestaetigungAcknowledged);

                } catch (final Throwable e) {
                    DecisionDepartmentActivator_Test.this.occuredThrowable = e;
                }
            }
        };
        new Thread(this.catchingThreadGroup, appRun).start();

        // ApplicationContext wird nicht verwendet!
        // Blockiert bis Test-Thread stop() rufft.
        applicationInstance.start((IApplicationContext) null);

        // FIXME mz 2008-07-18: This Test has to be fixed and conitnued
        // fail("This Test has to be fixed!");

        applicationInstance.stop();
    }

    // FIXME setUp wieder rein!
    // @Before
    public void UNsetUp() throws Exception {
        // ** Prepare Mocks...
        // Logger
        this.logger = new LoggerMock();

        // * MessagingService
        this.messagingService = this.createMessagingServiceMock();

        // * PrefeenceService
        this.preferenceService = this.createPreferenceServiceMock();

        // * LocalStoreConfigurationService
        this.localStoreConfigurationService = this
        .createLocalStoreConfigurationService();

        // * Andere...
        // * Andere...
        this.regelwerksBuilderService = EasyMock
        .createMock(RegelwerkBuilderService.class);
        final List<Regelwerk> list = Collections.emptyList();
        // FIXME Die nächste Zeile muss wieder rein:
        // EasyMock.expect(regelwerksBuilderService.gibAlleRegelwerke())
        // .andReturn(list).once();

        this.historyService = EasyMock.createNiceMock(HistoryService.class);

        this.executionService = new ExecutionServiceMock();

        // Replay....
        EasyMock.replay(this.preferenceService, this.regelwerksBuilderService,
                        this.historyService, this.localStoreConfigurationService);
    }

    // FIXME tearDown wieder rein!
    // @After
    public void UNtearDown() {
        // Clean-Ups.
        if (this.occuredThrowable != null) {
            throw new RuntimeException("Unhandled exception occurred.",
                                       this.occuredThrowable);
        }
        // Verify Mocks...
        EasyMock.verify(this.preferenceService, this.regelwerksBuilderService,
                        this.historyService, this.localStoreConfigurationService);
    }

    private MessagingSessionMock createAMSConsumerSession() {
        // TODO Maps befüllen
        // P_JMS_AMS_PROVIDER_URL_1
        // P_JMS_AMS_PROVIDER_URL_2
        //
        final Map<String, PostfachArt> expectedPostfachArtenForSources = new HashMap<String, PostfachArt>();
        final Map<String, Consumer> consumerForSources = new HashMap<String, Consumer>();
        final Map<String, PostfachArt> expectedPostfachArtenForDestination = new HashMap<String, PostfachArt>();
        final Map<String, Producer> producerForDestination = new HashMap<String, Producer>();

        expectedPostfachArtenForSources.put("P_JMS_AMS_TOPIC_COMMAND",
                                            PostfachArt.TOPIC);
        this.amsCommandConsumerMock = new ConsumerMock() {
            @Override
            public NAMSMessage receiveMessage() throws MessagingException,
            InterruptedException {
                throw new InterruptedException();
            }
        };
        consumerForSources.put("P_JMS_AMS_TOPIC_COMMAND",
                               this.amsCommandConsumerMock);

        final MessagingSessionMock amsConsumerSession = new MessagingSessionMock(
                                                                                 expectedPostfachArtenForSources, consumerForSources,
                                                                                 expectedPostfachArtenForDestination, producerForDestination);
        return amsConsumerSession;
    }

    private MessagingSession createAMSProducerSession() {
        // TODO Auto-generated method stub
        final Map<String, PostfachArt> expectedPostfachArtenForSources = new HashMap<String, PostfachArt>();
        final Map<String, Consumer> consumerForSources = new HashMap<String, Consumer>();
        final Map<String, PostfachArt> expectedPostfachArtenForDestination = new HashMap<String, PostfachArt>();
        final Map<String, Producer> producerForDestination = new HashMap<String, Producer>();

        expectedPostfachArtenForDestination.put(
                                                "P_JMS_AMS_TOPIC_DD_OUTBOX", PostfachArt.TOPIC);

        this.amsToDistributorProducerMock = new ProducerMock() {
            @Override
            public void sendeSystemnachricht(final SystemNachricht nachricht) {
                Assert
                .assertTrue((nachricht instanceof SyncronisationsAufforderungsSystemNachchricht));
            }

            @Override
            public void tryToClose() {
            }
        };
        producerForDestination.put("P_JMS_AMS_TOPIC_DD_OUTBOX",
                                   this.amsToDistributorProducerMock);

        final MessagingSessionMock amsProducerSession = new MessagingSessionMock(
                                                                                 expectedPostfachArtenForSources, consumerForSources,
                                                                                 expectedPostfachArtenForDestination, producerForDestination);
        return amsProducerSession;
    }

    private MessagingSessionMock createEXTConsumerSession() {
        // TODO Maps befüllen
        // P_JMS_EXTERN_PROVIDER_URL_1
        // P_JMS_EXTERN_PROVIDER_URL_2
        final Map<String, PostfachArt> expectedPostfachArtenForSources = new HashMap<String, PostfachArt>();
        final Map<String, Consumer> consumerForSources = new HashMap<String, Consumer>();
        final Map<String, PostfachArt> expectedPostfachArtenForDestination = new HashMap<String, PostfachArt>();
        final Map<String, Producer> producerForDestination = new HashMap<String, Producer>();

        expectedPostfachArtenForSources.put("P_JMS_EXT_TOPIC_COMMAND",
                                            PostfachArt.TOPIC);
        final ConsumerMock extCommandConsumerMock = new ConsumerMock();
        consumerForSources.put("P_JMS_EXT_TOPIC_COMMAND",
                               extCommandConsumerMock);
        expectedPostfachArtenForSources.put("P_JMS_EXT_TOPIC_ALARM",
                                            PostfachArt.TOPIC);
        final ConsumerMock extAlarmConsumerMock = new ConsumerMock();
        consumerForSources.put("P_JMS_EXT_TOPIC_ALARM", extAlarmConsumerMock);

        final MessagingSessionMock amsConsumerSession = new MessagingSessionMock(
                                                                                 expectedPostfachArtenForSources, consumerForSources,
                                                                                 expectedPostfachArtenForDestination, producerForDestination);
        return amsConsumerSession;
    }

    private LocalStoreConfigurationService createLocalStoreConfigurationService()
    throws StorageError, StorageException,
    InconsistentConfigurationException,
    UnknownConfigurationElementError {
        final LocalStoreConfigurationService result = EasyMock
        .createMock(LocalStoreConfigurationService.class);

        final ReplicationStateDTO rplStateIdle = new ReplicationStateDTO();
        rplStateIdle.setReplicationState(ReplicationState.FLAGVALUE_SYNCH_IDLE);
        EasyMock.expect(result.getCurrentReplicationState()).andReturn(
                                                                       rplStateIdle).once();

        final ReplicationStateDTO rplStartSyncronisation = new ReplicationStateDTO();
        rplStartSyncronisation
        .setReplicationState(ReplicationState.FLAGVALUE_SYNCH_FMR_TO_DIST_SENDED);
        result.saveCurrentReplicationState(EasyMock.eq(rplStartSyncronisation));
        EasyMock.expectLastCall().once();

        return result;
    }

    private MessagingServiceMock createMessagingServiceMock() {
        // URLs
        final Map<String, String[]> expectedUrlsForClientIds = new HashMap<String, String[]>();
        expectedUrlsForClientIds.put("amsConsumer", new String[] {
                                                                  "P_JMS_AMS_PROVIDER_URL_1", "P_JMS_AMS_PROVIDER_URL_2" });
        expectedUrlsForClientIds.put("extConsumer", new String[] {
                                                                  "P_JMS_EXTERN_PROVIDER_URL_1", "P_JMS_EXTERN_PROVIDER_URL_2" });
        expectedUrlsForClientIds.put("amsProducer",
                                     new String[] { "P_JMS_AMS_SENDER_PROVIDER_URL" });
        // Session
        final Map<String, MessagingSession> sessionsForClientIds = new HashMap<String, MessagingSession>();
        sessionsForClientIds
        .put("amsConsumer", this.createAMSConsumerSession());
        sessionsForClientIds
        .put("extConsumer", this.createEXTConsumerSession());
        sessionsForClientIds
        .put("amsProducer", this.createAMSProducerSession());
        // Service
        return new MessagingServiceMock(expectedUrlsForClientIds,
                                        sessionsForClientIds);
    }

    private PreferenceService createPreferenceServiceMock() {
        final PreferenceService result = EasyMock.createMock(PreferenceService.class);

        EasyMock.expect(result.getString(PreferenceServiceDatabaseKeys.P_APP_DATABASE_CONNECTION))
                .andReturn("P_APP_DATABASE_CONNECTION").anyTimes();

        EasyMock.expect(result.getString(PreferenceServiceDatabaseKeys.P_APP_DATABASE_USER))
                .andReturn("P_APP_DATABASE_USER").anyTimes();

        EasyMock.expect(result.getString(PreferenceServiceDatabaseKeys.P_APP_DATABASE_PASSWORD))
                .andReturn("P_APP_DATABASE_PASSWORD").anyTimes();

        EasyMock.expect(result.getString(PreferenceServiceDatabaseKeys.P_APP_DATABASE_TYPE))
                .andReturn("P_APP_DATABASE_TYPE").anyTimes();


        EasyMock
        .expect(
                result
                .getString(PreferenceServiceJMSKeys.P_JMS_AMS_PROVIDER_URL_1))
                .andReturn("P_JMS_AMS_PROVIDER_URL_1").anyTimes();
        EasyMock
        .expect(
                result
                .getString(PreferenceServiceJMSKeys.P_JMS_AMS_PROVIDER_URL_2))
                .andReturn("P_JMS_AMS_PROVIDER_URL_2").anyTimes();

        EasyMock
        .expect(
                result
                .getString(PreferenceServiceJMSKeys.P_JMS_EXTERN_PROVIDER_URL_1))
                .andReturn("P_JMS_EXTERN_PROVIDER_URL_1").anyTimes();
        EasyMock
        .expect(
                result
                .getString(PreferenceServiceJMSKeys.P_JMS_EXTERN_PROVIDER_URL_2))
                .andReturn("P_JMS_EXTERN_PROVIDER_URL_2").anyTimes();

        EasyMock
        .expect(
                result
                .getString(PreferenceServiceJMSKeys.P_JMS_EXT_TOPIC_ALARM))
                .andReturn("P_JMS_EXT_TOPIC_ALARM").anyTimes();
        EasyMock
        .expect(
                result
                .getString(PreferenceServiceJMSKeys.P_JMS_EXT_TOPIC_COMMAND))
                .andReturn("P_JMS_EXT_TOPIC_COMMAND").anyTimes();
        EasyMock
        .expect(
                result
                .getString(PreferenceServiceJMSKeys.P_JMS_AMS_TOPIC_COMMAND))
                .andReturn("P_JMS_AMS_TOPIC_COMMAND").anyTimes();

        EasyMock
        .expect(
                result
                .getString(PreferenceServiceJMSKeys.P_JMS_AMS_SENDER_PROVIDER_URL))
                .andReturn("P_JMS_AMS_SENDER_PROVIDER_URL").anyTimes();
        EasyMock
        .expect(
                result
                .getString(PreferenceServiceJMSKeys.P_JMS_AMS_TOPIC_DD_OUTBOX))
                .andReturn("P_JMS_AMS_TOPIC_DD_OUTBOX").anyTimes();

        return result;
    }
}
